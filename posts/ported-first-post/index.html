<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A (Not So) Brief Overview Of This Site's Setup | 0x15AAC</title>
<meta name=keywords content><meta name=description content="Editor&rsquo;s Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn&rsquo;t totally practical to maintain and has since been replaced.
It seems only fitting to have the first post of a self-built blog to be about, well, the blog! I&rsquo;ll list the technologies I used and why I chose them. In a later post I&rsquo;ll cover details on how I put them together."><meta name=author content="Isaac Parker"><link rel=canonical href=https://isaacparker.co/posts/ported-first-post/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://isaacparker.co/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://isaacparker.co/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://isaacparker.co/favicon-32x32.png><link rel=apple-touch-icon href=https://isaacparker.co/apple-touch-icon.png><link rel=mask-icon href=https://isaacparker.co/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://isaacparker.co/posts/ported-first-post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="A (Not So) Brief Overview Of This Site's Setup"><meta property="og:description" content="Editor&rsquo;s Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn&rsquo;t totally practical to maintain and has since been replaced.
It seems only fitting to have the first post of a self-built blog to be about, well, the blog! I&rsquo;ll list the technologies I used and why I chose them. In a later post I&rsquo;ll cover details on how I put them together."><meta property="og:type" content="article"><meta property="og:url" content="https://isaacparker.co/posts/ported-first-post/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-11-14T22:40:00-06:00"><meta property="article:modified_time" content="2022-04-23T11:25:55-06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A (Not So) Brief Overview Of This Site's Setup"><meta name=twitter:description content="Editor&rsquo;s Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn&rsquo;t totally practical to maintain and has since been replaced.
It seems only fitting to have the first post of a self-built blog to be about, well, the blog! I&rsquo;ll list the technologies I used and why I chose them. In a later post I&rsquo;ll cover details on how I put them together."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://isaacparker.co/posts/"},{"@type":"ListItem","position":2,"name":"A (Not So) Brief Overview Of This Site's Setup","item":"https://isaacparker.co/posts/ported-first-post/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A (Not So) Brief Overview Of This Site's Setup","name":"A (Not So) Brief Overview Of This Site\u0027s Setup","description":"Editor\u0026rsquo;s Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn\u0026rsquo;t totally practical to maintain and has since been replaced.\nIt seems only fitting to have the first post of a self-built blog to be about, well, the blog! I\u0026rsquo;ll list the technologies I used and why I chose them. In a later post I\u0026rsquo;ll cover details on how I put them together.","keywords":[],"articleBody":" Editor‚Äôs Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn‚Äôt totally practical to maintain and has since been replaced.\nIt seems only fitting to have the first post of a self-built blog to be about, well, the blog! I‚Äôll list the technologies I used and why I chose them. In a later post I‚Äôll cover details on how I put them together.\nThe Stack Digital Ocean VPS Running Ubuntu 16.04\nDocker (Using Docker-Compose)\nWeb server (frontend/backend) PostgreSQL Go (Backend)\ndgrijalva/jwt-go (Auth) Frontend¬†The frontend consists of React (w/ Babel), and Mobx for state management. Styling is done with the ever-wonderful SCSS, a variant of Sass. I‚Äôm using a few plugins, including the excellent react-rte package which makes editing content on this site a breeze. The client/server interface is handled by my own API wrapper, but I plan to switch to something more robust like Backbone. Using React for this site was an easy choice. After wrangling with manually generated HTML inside Javascript for years, the recent influx of better client-side tooling has been more than welcome. Even before this project I‚Äôve had my eyes on Angular 2/4, Vue.JS, Mithril.js and React. Soon after deciding on Angular 2 (and then 4) as my frontend tool of choice, I became interested in alternatives. I test drove both Vue.JS and Mithril, but ultimately settled on React. Initially, I had stayed away from React in part because the JSX within the components seemed awkward. The inline markup reminded me of manually generating HTML in Javascript, so I had Angular which used a more familiar (if somewhat quirky) template system. However my initial fears of an overly-crowded component turned out to be unjustified. By combining concise CSS, reusable components, and though-out state management, it‚Äôs not hard to have very manageable components in React. SCSS was by far the easiest technology chose I made for this site. Variables, imports, mixins and nested rules are incredibly useful when trying to build consistent style, all while being able to tweak things easily. The features are easy to learn, but valid CSS is inherently valid SCSS, so mixing it in (pun intended) is easy-breezy.\nBackend Most of the web-based applications I‚Äôve built and worked on over the past few years have been Django projects. The Django framework is fantastic for form-driven applications, and applications with complex data models. The ORM layer is an absolute dream, the built-in authentication models are powerful, and the auto-generated admin site is a huge productivity booster. I could go on singing Django‚Äôs praises, but all of Django‚Äôs benefits are exactly why I was itching to try something new. That, coupled with a lack of a native Restful API integration and frustration with available plugins* to add such features fueled my search for something new. So at this point, I knew I wanted to write the frontend in React, and I wanted a supporting backend. I liked Django‚Äôs ORM, but I could do without the friction I had experienced between a React-style app and Django‚Äôs Auth framework. Learning a new language sounded fun too, so I added that to the mental list of requirements.\nThus, my list of not-too-technical requirements was born:\nNot Django A language I don‚Äôt have much experience with React-friendly API, likely REST Sane Authentication Snazzy ORM From this point I was off to explore options that somewhat fit those requirements.\nOption 0: Django with GraphQL Ok, so not really straying from Django, but this would be using a plugin to provide a GraphQL service that could be consumed by Relay Modern on the client. That kind of setup really seems nice. However, after initially setting up a dummy project to play around with React/Relay Modern + Django/Graphene I quickly hit a sore spot. Graphene (at the time, possibly still today) wasn‚Äôt totally compatible with Relay Modern. Combined with it still being Django (see above) I scraped this idea and moved along.\nOption 1: Node/Express This one seemed clear, despite my experience with Javascript. Since I‚Äôd be writing the frontend in Javascript, why not the backend too? I actually initially settled on this stack, and began stubbing out a skeleton for this site. I chose MongoDB + Mongoose for persistence, and Passport.js for authentication. This stack stack seemed great, and I set about adding basic CRUD functionality ‚Äì until a yearning for learning a new language nagged at me again. ‚ÄúI‚Äôve done this before‚Äù nagged the voice in my head. I had, but don‚Äôt they say practice make perfect? Maybe, but that gets boring! So I went back to the drawing board‚Ä¶ Note: If this was a commercial website, collaborative project , or almost any other type of website, there‚Äôs a strong chance I would have continued to use this stack. It‚Äôs common, supportable, and each of the projects I mentioned have a pretty substantial developer/user-base. So really, the only reason I decided against a Node/Express stack was familiarity!\nOption 2: .NET Core 2.0 + Entity Framework Core This setup was a strong contender. As above, it doesn‚Äôt check off box #2, but I had hope! After having used .NET Core 2.0 with Entity Framework Core as a basic data store for a Chrome Extension, I was impressed. Database drivers for MySQL and PostgreSQL were first-class and quality 3rd party, respectively. After spinning up a starter project with local authentication, it really seemed to be good to go. However, after attempting to combine .NET Core‚Äôs native Rest API components and native authentication system, I ran into issues ‚Äì not unlike my attempt to shoehorn Django‚Äôs built-in auth framework into something React-friendly (don‚Äôt do it). Luckily there was a 3rd party package that could help with REST API authentication. It seemed great, until I read through some of the open issues and found that the project only supported .NET Core 1.x, with no real word on 2.x support. Coupling that with some relatively high memory usage I was seeing for my very simple Chrome Extension REST API service, I figured I‚Äôd look for something else. At this point (or even before!) you may have the urge to call me crazy, bonkers, or mildly insane for hopscotching from one stack to another. That‚Äôs totally fair. Please leave your insults in the comments ‚Äì if I ever get around to adding them._\nOption 3: Ruby/RoR While RoR is used in a lot of projects and would have fit nearly all of my arbitrary requirements, I ultimately decided against it. Firstly because Ruby has never really piqued my interest, namely because of my (certainly biased, probably incorrect) assertion that ‚ÄúRuby is like Python, but not as good.‚Äù Couple that with a number of RoR‚Äôs direct similarities with Django, and I wondered how far out of my comfort zone I‚Äôd actually be.\nOption 4: PHP Writing this site in PHP would have been a throwback to my first days of making server-side web abominations applications. My slight distaste the actual language aside, it seemed only logical to consider using PHP. Plus, I hadn‚Äôt used modern (\u003e~5.6) PHP it couldn‚Äôt hurt to give it another go. In terms of frameworks, I‚Äôd heard of Laravel and Symfony before. After a little searching, I went ahead and spent a couple hours with Laravel. I was very impressed with the built-in features, with many of them seeming to parallel those found in Django. However, because of those parallels and my initial preference to avoid PHP led me to look at more alternatives for this particular project. That said, I‚Äôve got some ideas of what I may use Laravel for in the future. Now, I can only hope I‚Äôve riled you up, insulted your favorite language and given some weak reasons for not using a great stack. Who knows, maybe that was my plan. Perhaps I actually wrote this all in Elm and Haskell** and this is me bashing everything else. üòÄ¬†Option 5: Rust/Swift Ok, so am I actually verifiably insane? Err‚Ä¶maybe. But these really were contenders and I‚Äôd say my final choice isn‚Äôt too different. For Rust there‚Äôs AreWeWebYet? tracking the viability of using Rust for web applications. For what I needed I could have probably used it, and Swift also seemed to have some fairly decent packages equipping it for server-side use. While I didn‚Äôt chose Swift or Rust (despite glowing reviews about Rust from by buddy, sfuller, the idea of a natively-compiled strongly-typed backend language really intrigued me. That let me to my final and chosen option‚Ä¶\nOption 6: Go (Golang) I chose one ‚Äì took long enough! This is the language this site is actually served via. As mentioned above, I thought it would be interesting to use a strongly-typed language on the server, specifically one without a runtime √† la Java or C#. Although this wasn‚Äôt a technical requirement (because only my RESTful API requirement was), it certainly sounded fun.\nMy Setup Out of the box Go has good support for working with JSON, it has built-in HTTP Server (and client) packages, and even some SQL database support. But in a very differing philosophy from that of Django, I‚Äôve replaced and added a number of the core components of my server. Here are the external packages I‚Äôm including:\ngithub.com/dgrijalva/jwt-go While researching the Node/Express stack I came across JWTs and had to know more. By the I had settled on Go as the language, I already knew I wanted to be using JWTs with whatever language I picked. The claims section in particular (when used correctly!) makes displaying relevant data easy in a client/server setup. Plus, outside of the web, JWTs are perfect for native, mobile, or desktop apps. github.com/gorilla/mux Mux is a URL router, somewhat similar to Django‚Äôs, but even nicer (and I like Django‚Äôs). It‚Äôs not feature-for-feature equivalent, but it‚Äôs great. golang.org/x/crypto/bcrypt Go‚Äôs bcrypt module does exactly what you‚Äôd expect‚Ñ¢Ô∏è ‚Äì it hashes passwords (or, currently, the password). github.com/jinzhu/gorm Gorm is a Go ORM (see what they did there?). At times Gorm leaves me really missing the power + elegance of Django‚Äôs ORM, but for this site it really hasn‚Äôt been a problem. Plus, if I were in a situation where I needed a more optimized SQL query for something, it cleanly steps out of the way and lets you do just that. In the future I‚Äôd say I‚Äôm really likely to use this setup again. I haven‚Äôt found any of the pieces of this stack to be nagging at me to replace them, and the ease of adding features has been great. If you have any thoughts or questions, or if you find any errors, please let me know in the comments (coming soon! EDIT: now up!). I‚Äôd be delighted to hear about your experience using any of the stacks I‚Äôve listed, and as well as ones I‚Äôve left out. What do you like about them, what would you change?\n*I‚Äôve been using Django Rest Framework for a few months on a different project. While it‚Äôs pretty solid project, I find some very common tasks to take considerably more effort than I would like. ** No, I didn‚Äôt. At least, not yet.\n","wordCount":"1861","inLanguage":"en","datePublished":"2017-11-14T22:40:00-06:00","dateModified":"2022-04-23T11:25:55-06:00","author":{"@type":"Person","name":"Isaac Parker"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://isaacparker.co/posts/ported-first-post/"},"publisher":{"@type":"Organization","name":"0x15AAC","logo":{"@type":"ImageObject","url":"https://isaacparker.co/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://isaacparker.co/ accesskey=h title="0x15AAC (Alt + H)">0x15AAC</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://isaacparker.co/ title=Blog><span>Blog</span></a></li><li><a href=https://isaacparker.co/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A (Not So) Brief Overview Of This Site's Setup</h1><div class=post-meta><span title='2017-11-14 22:40:00 -0600 -0600'>November 14, 2017</span>&nbsp;¬∑&nbsp;Isaac Parker</div></header><div class=post-content><blockquote><p>Editor&rsquo;s Note: This was originally posted on my previous blog platform. While building that site was a great personal learning experience, it wasn&rsquo;t totally practical to maintain and has since been replaced.</p></blockquote><p>It seems only fitting to have the first post of a self-built blog to be about, well, the blog! I&rsquo;ll list the technologies I used and why I chose them. In a later post I&rsquo;ll cover details on how I put them together.</p><h2 id=the-stack>The Stack<a hidden class=anchor aria-hidden=true href=#the-stack>#</a></h2><ul><li><p>Digital Ocean VPS Running Ubuntu 16.04</p></li><li><p>Docker (Using Docker-Compose)</p><ul><li>Web server (frontend/backend)</li><li>PostgreSQL</li></ul></li><li><p>Go (Backend)</p><ul><li>dgrijalva/jwt-go (Auth)</li></ul></li></ul><h2 id=frontendnbsp>Frontend¬†<a hidden class=anchor aria-hidden=true href=#frontendnbsp>#</a></h2><p>The frontend consists of React (w/ Babel), and Mobx for state management. Styling is done with the ever-wonderful SCSS, a variant of Sass. I&rsquo;m using a few plugins, including the excellent <a href=https://github.com/sstur/react-rte>react-rte</a> package which makes editing content on this site a breeze. The client/server interface is handled by my own API wrapper, but I plan to switch to something more robust like Backbone.
Using React for this site was an easy choice. After wrangling with manually generated HTML inside Javascript for years, the recent influx of better client-side tooling has been more than welcome. Even before this project I&rsquo;ve had my eyes on Angular 2/4, Vue.JS, <a href=https://mithril.js.org>Mithril.js</a> and React. Soon after deciding on Angular 2 (and then 4) as my frontend tool of choice, I became interested in alternatives. I test drove both Vue.JS and Mithril, but ultimately settled on React.
Initially, I had stayed away from React in part because the JSX within the components seemed awkward. The inline markup reminded me of manually generating HTML in Javascript, so I had Angular which used a more familiar (if somewhat quirky) template system. However my initial fears of an overly-crowded component turned out to be unjustified. By combining concise CSS, reusable components, and though-out state management, it&rsquo;s not hard to have very manageable components in React.
SCSS was by far the easiest technology chose I made for this site. Variables, imports, mixins and nested rules are incredibly useful when trying to build consistent style, all while being able to tweak things easily. The features are easy to learn, but valid CSS is inherently valid SCSS, so mixing it in (pun intended) is easy-breezy.</p><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>Most of the web-based applications I&rsquo;ve built and worked on over the past few years have been <a href=https://www.djangoproject.com/>Django</a> projects. The Django framework is fantastic for form-driven applications, and applications with complex data models. The ORM layer is an absolute dream, the built-in authentication models are powerful, and the auto-generated admin site is a huge productivity booster. I could go on singing Django&rsquo;s praises, but all of Django&rsquo;s benefits are exactly why I was itching to try something new. That, coupled with a lack of a native Restful API integration and frustration with available plugins* to add such features fueled my search for something new.
So at this point, I knew I wanted to write the frontend in React, and I wanted a supporting backend. I liked Django&rsquo;s ORM, but I could do without the friction I had experienced between a React-style app and Django&rsquo;s Auth framework. Learning a new language sounded fun too, so I added that to the mental list of requirements.</p><p>Thus, my list of not-too-technical requirements was born:</p><ul><li>Not Django</li><li>A language I don&rsquo;t have much experience with</li><li>React-friendly API, likely REST</li><li>Sane Authentication</li><li>Snazzy ORM</li></ul><p>From this point I was off to explore options that somewhat fit those requirements.</p><p><strong>Option 0: Django with GraphQL</strong>
Ok, so not really straying from Django, but this would be using a plugin to provide a GraphQL service that could be consumed by Relay Modern on the client. That kind of setup really seems nice. However, after initially setting up a dummy project to play around with React/Relay Modern + Django/Graphene I quickly hit a sore spot. Graphene (at the time, possibly still today) wasn&rsquo;t totally compatible with Relay Modern. Combined with it still being Django (see above) I scraped this idea and moved along.</p><p><strong>Option 1: Node/Express</strong>
This one seemed clear, despite my experience with Javascript. Since I&rsquo;d be writing the frontend in Javascript, why not the backend too? I actually initially settled on this stack, and began stubbing out a skeleton for this site. I chose MongoDB + Mongoose for persistence, and Passport.js for authentication. This stack stack seemed great, and I set about adding basic CRUD functionality &ndash; until a yearning for learning a new language nagged at me again. &ldquo;I&rsquo;ve done this before&rdquo; nagged the voice in my head. I had, but don&rsquo;t they say practice make perfect? Maybe, but that gets boring! ¬†So I went back to the drawing board&mldr;
<em>Note: If this was a commercial website, collaborative project , or almost any other type of website, there&rsquo;s a strong chance I would have continued to use this stack. It&rsquo;s common, supportable, and each of the projects I mentioned have a pretty substantial developer/user-base. So really, the only reason I decided against a Node/Express stack was familiarity!</em></p><p><strong>Option 2: .NET Core 2.0 + Entity Framework Core</strong>
This setup was a strong contender. As above, it doesn&rsquo;t check off box #2, but I had hope! After having used .NET Core 2.0 with Entity Framework Core as a basic data store for a Chrome Extension, I was impressed. Database drivers for MySQL and PostgreSQL were first-class and quality 3rd party, respectively. After spinning up a starter project with local authentication, it really seemed to be good to go. However, after attempting to combine .NET Core&rsquo;s native Rest API components and native authentication system, I ran into issues &ndash; not unlike my attempt to shoehorn Django&rsquo;s built-in auth framework into something React-friendly (don&rsquo;t do it). Luckily there was a 3rd party package that could help with REST API authentication. It seemed great, until I read through some of the open issues and found that the project only supported .NET Core 1.x, with no real word on 2.x support. Coupling that with some relatively high memory usage I was seeing for my very simple Chrome Extension REST API service, I figured I&rsquo;d look for something else.
<em>At this point (or even before!) you may have the urge to call me crazy, bonkers, or mildly insane for hopscotching from one stack to another. That&rsquo;s totally fair. Please leave your insults in the comments &ndash; if I ever get around to adding them.</em>_</p><p><strong>Option 3: Ruby/RoR</strong>
While RoR is used in a lot of projects and would have fit nearly all of my arbitrary requirements, I ultimately decided against it. Firstly because Ruby has never really piqued my interest, namely because of my (<strong>certainly biased, probably incorrect</strong>) assertion that <em>&ldquo;Ruby is like Python, but not as good.&rdquo;</em> Couple that with a number of RoR&rsquo;s direct similarities with Django, and I wondered how far out of my comfort zone I&rsquo;d actually be.</p><p><strong>Option 4: PHP</strong>
Writing this site in PHP would have been a throwback to my first days of making server-side web <del>abominations</del> applications. My slight distaste the actual language aside, it seemed only logical to consider using PHP. Plus, I hadn&rsquo;t used modern (>~5.6) PHP it couldn&rsquo;t hurt to give it another go. In terms of frameworks, I&rsquo;d heard of Laravel and Symfony before. After a little searching, I went ahead and spent a couple hours with Laravel. I was very impressed with the built-in features, with many of them seeming to parallel those found in Django. However, because of those parallels and my initial preference to avoid PHP ¬†led me to look at more alternatives for this particular project. That said, I&rsquo;ve got some ideas of what I may use Laravel for in the future.
<em>Now, I can only hope I&rsquo;ve riled you up, insulted your favorite language and given some weak reasons for not using a great stack. Who knows, maybe that was my plan. Perhaps I actually wrote this all in Elm and Haskell** and this is me bashing everything else. üòÄ¬†</em></p><p><strong>Option 5: Rust/Swift</strong>
Ok, so am I actually <em>verifiably</em> insane? Err&mldr;maybe. But these really were contenders and I&rsquo;d say my final choice isn&rsquo;t too different. For Rust there&rsquo;s <a href=http://www.arewewebyet.org/>AreWeWebYet?</a> tracking the viability of using Rust for web applications. For what I needed I could have probably used it, and Swift also seemed to have some fairly decent packages equipping it for server-side use. While I didn&rsquo;t chose Swift or Rust (despite glowing reviews about Rust from by buddy, <a href=https://samfullerstudios.com/>sfuller</a>, the idea of a natively-compiled strongly-typed backend language really intrigued me. That let me to my final and chosen option&mldr;</p><p><strong>Option 6: <a href=https://golang.org/>Go</a> (Golang)</strong>
I chose one &ndash; took long enough! This is the language this site is actually served via. As mentioned above, I thought it would be interesting to use a strongly-typed language on the server, specifically one without a runtime √† la Java or C#. Although this wasn&rsquo;t a technical requirement (because only my RESTful API requirement was), it certainly sounded fun.</p><h2 id=my-setup>My Setup<a hidden class=anchor aria-hidden=true href=#my-setup>#</a></h2><p>Out of the box Go has good support for working with JSON, it has built-in HTTP Server (and client) packages, and even some SQL database support. But in a very differing philosophy from that of Django, I&rsquo;ve replaced and added a number of the core components of my server. ¬†Here are the external packages I&rsquo;m including:</p><ul><li><a href=http://github.com/dgrijalva/jwt-go>github.com/dgrijalva/jwt-go</a> While researching the Node/Express stack I came across JWTs and had to know more. By the I had settled on Go as the language, I already knew I wanted to be using JWTs with whatever language I picked. The claims section in particular (when used correctly!) makes displaying ¬†relevant data easy in a client/server setup. Plus, outside of the web, JWTs are perfect for native, mobile, or desktop apps.</li><li><a href=http://github.com/gorilla/mux>github.com/gorilla/mux</a> Mux is a URL router, somewhat similar to Django&rsquo;s, but even nicer (and I like Django&rsquo;s). It&rsquo;s not feature-for-feature equivalent, but it&rsquo;s great.</li><li><a href=http://golang.org/x/crypto/bcrypt>golang.org/x/crypto/bcrypt</a> Go&rsquo;s <code>bcrypt</code> module does <em>exactly what you&rsquo;d expect‚Ñ¢Ô∏è</em> &ndash; it hashes passwords (or, currently, the password).</li><li><a href=http://github.com/jinzhu/gorm>github.com/jinzhu/gorm</a> Gorm is a Go ORM (see what they did there?). At times Gorm leaves me really missing the power + elegance of Django&rsquo;s ORM, but for this site it really hasn&rsquo;t been a problem. Plus, if I were in a situation where I needed a more optimized SQL query for something, it cleanly steps out of the way and lets you do just that.</li></ul><p>In the future I&rsquo;d say I&rsquo;m really likely to use this setup again. I haven&rsquo;t found any of the pieces of this stack to be nagging at me to replace them, and the ease of adding features has been great.
If you have any thoughts or questions, or if you find any errors, please let me know in the comments (<del>coming soon!</del> EDIT: now up!). I&rsquo;d be delighted to hear about your experience using any of the stacks I&rsquo;ve listed, and as well as ones I&rsquo;ve left out. What do you like about them, what would you change?</p><p>*I&rsquo;ve been using Django Rest Framework for a few months on a different project. While it&rsquo;s pretty solid project, I find some very common tasks to take considerably more effort than I would like.
** No, I didn&rsquo;t. At least, not yet.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>¬© 2024 Isaac Parker</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>